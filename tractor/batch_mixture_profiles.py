# Copyright 2011 David W. Hogg and Dustin Lang.  All rights reserved.
from __future__ import print_function
if __name__ == '__main__':
    import matplotlib
    matplotlib.use('Agg')
    import pylab as plt
    import matplotlib.cm as cm
import numpy as np
import cupy as cp

# magic arrays, generated by running optimize_mixture_profiles.py:
# (note optimize_mixture_profiles.py now lives in Hogg's TheTractor github repo)
# for "exp" we use the 6-component "lux" models
exp_amp = np.array([2.34853813e-03,   3.07995260e-02,   2.23364214e-01,
                    1.17949102e+00,   4.33873750e+00,   5.99820770e+00])
exp_var = np.array([1.20078965e-03,   8.84526493e-03,   3.91463084e-02,
                    1.39976817e-01,   4.60962500e-01,   1.50159566e+00])
exp_amp /= np.sum(exp_amp)

# for "dev" we use the 8-component "luv" models
dev_amp = np.array([4.26347652e-02,   2.40127183e-01,   6.85907632e-01,   1.51937350e+00,
                    2.83627243e+00,   4.46467501e+00,   5.72440830e+00,   5.60989349e+00])
dev_var = np.array([2.23759216e-04,   1.00220099e-03,   4.18731126e-03,   1.69432589e-02,
                    6.84850479e-02,   2.87207080e-01,   1.33320254e+00,   8.40215071e+00])
#dev_amp /= np.sum(dev_amp)

########## Delta function core to correct for softening
dev_core = 0.010233
dev_amp *= (1. - dev_core) / np.sum(dev_amp)
dev_amp = np.append(dev_amp, dev_core)
dev_var = np.append(dev_var, 0.)
####################

class ImageDerivs(object):
    '''This supercedes the img_dervis list
        N = number of blobs
        nmogs = number of mogs
        nfft = number of ffts
        K, D = dimensions of mean, var
        mogs = BatchMixtureOfGaussians
        ffts = batchMixtureOfGaussians
        names = list of amixes.name
        step = list of amixes.step
    '''

    def __init__(self, amixes, IM, IF, K, D, mogweights, fftweights, px, py, mux, muy, mmpix, mmie, mh, mw, counts, cdi, roi, sky, dx, dy):
        N = len(amixes)
        nmogs = IM.sum(axis=1).max()
        nfft = IF.sum(axis=1).max()
        self.N = N
        self.nmogs = nmogs
        self.nfft = nfft
        self.K = K
        self.D = D
        self.mogs = None
        self.ffts = None
        self.names = []
        self.steps = []

        self.mux = mux
        self.muy = muy
        self.mmpix = cp.asarray(mmpix)
        self.mmie = cp.asarray(mmie)
        self.mh = mh
        self.mw = mw
        self.counts = counts
        self.cdi = cdi
        self.roi = roi
        self.sky = sky

        self.dx = dx
        self.dy = dy

        if self.nmogs > 0:
            amp = np.zeros((N, nmogs))
            mean = np.zeros((N, nmogs, D))
            var = np.zeros((N, nmogs, D, D))
            for i, amix in enumerate(amixes):
                (name, mix, step) = amix
                nm = IM[i].sum()
                amp[i][:nm] = mix.amp[IM[i]] * mogweights[i][IM[i]]
                mean[i][:nm] = mix.mean[IM[i], :] + np.array([px, py])[np.newaxis, :]
                var[i][:nm] = mix.var[IM[i], :, :]
            #self.mogs = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
            self.mog_amp = amp
            self.mog_mean = mean
            self.mog_var = var
        if self.nfft > 0:
            amp = np.zeros((N, nfft))
            mean = np.zeros((N, nfft, D))
            var = np.zeros((N, nfft, D, D))
            for i, amix in enumerate(amixes):
                (name, mix, step) = amix
                nf = IF[i].sum()
                amp[i][:nf] = mix.amp[IF[i]] * fftweights[i][IF[i]]
                mean[i][:nf] = mix.mean[IF[i], :]
                var[i][:nf] = mix.var[IF[i], :, :]
            #self.ffts = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
            self.fft_amp = amp
            self.fft_mean = mean
            self.fft_var = var
        for name,mix,step in amixes:
            self.names.append(name)
            self.steps.append(step)
        self.steps = np.array(self.steps, dtype=np.float32)

    def tostr(self):
        print("****** ImageDerivs *****")
        print(f'\t{self.N=}, {self.nmogs=}, {self.nfft=}, {self.K=}, {self.D=}')
        if self.mogs is None:
            print ("No Mogs")
        else:
            print ("Mogs ", self.mogs)
        if self.ffts is None:
            print ("No FFTs")
        else:
            print("FFTS", self.ffts)
        print ("Names ", self.names)
        print ("Steps ", self.steps)
        print (f'\t{self.mux=}, {self.muy=}, {self.mh=}, {self.mw=}')
        print (f'\t{self.counts=}, {self.cdi=}, {self.roi=}')


class BatchImageParams(object):
    '''Image Params for a set of images
        img_derivs = list of ImageDerivs
        P = 3d array (Nimages, nw, nv)
        v, w = 1d vectors
    '''

    def __init__(self, P, v, w, psf_mogs):
        self._initialized = False
        self.P = P
        self.v = v
        self.w = w
        self.psf_mogs = psf_mogs

        self.mogs = None
        self.ffts = None

        self.Nimages = 0 
        self.nv = len(v)
        self.nw = len(w)

        self.maxK = 0
        self.maxD = 0
        self.maxNd = 0
        self.maxNmogs = 0
        self.maxNfft = 0

        self.img_derivs = []
        self.mux = None
        self.muy = None

        self.mh = 0
        self.mw = 0

    def add_image_deriv(self, imderiv):
        self.img_derivs.append(imderiv)
        self.Nimages += 1

        self.maxK = max(self.maxK, imderiv.K)
        self.maxD = max(self.maxD, imderiv.D)
        self.maxNd = max(self.maxNd, imderiv.N)
        self.maxNmogs = max(self.maxNmogs, imderiv.nmogs)
        self.maxNfft = max(self.maxNfft, imderiv.nfft)

        self.mh = max(self.mh, imderiv.mh)
        self.mw = max(self.mw, imderiv.mw)

    def collect_params(self):
        assert(self._initialized is False)
        self._initialized = True
        self.mux = cp.asarray([[imderiv.mux]*self.maxNd for imderiv in self.img_derivs]).ravel()
        self.muy = cp.asarray([[imderiv.muy]*self.maxNd for imderiv in self.img_derivs]).ravel()

        self.pix = cp.zeros((self.Nimages, self.mh, self.mw), dtype = np.float32 )
        self.ie = cp.zeros_like(self.pix)
        self.counts = cp.zeros(self.Nimages, dtype=np.float32)
        self.cdi = np.zeros((self.Nimages, 2,2), dtype=np.float32)
        self.roi = np.zeros((self.Nimages, 4), dtype=np.int)
        self.sky = cp.zeros(self.Nimages, dtype=np.float32)
        self.steps = np.zeros((self.Nimages, self.maxNd), dtype=np.float32)

        for i, imderiv in enumerate(self.img_derivs):
            self.pix[i, :,:] = cp.pad(imderiv.mmpix, ((0, self.mh - imderiv.mmpix.shape[0]), (0, self.mw - imderiv.mmpix.shape[1])), mode='constant',constant_values=(cp.float32(0.0),))
            self.ie[i, :,:] = cp.pad(imderiv.mmie, ((0, self.mh - imderiv.mmie.shape[0]), (0, self.mw - imderiv.mmie.shape[1])), mode='constant',constant_values=(cp.float32(0.0),))
            self.counts[i] = imderiv.counts
            self.cdi[i] = imderiv.cdi
            self.roi[i] = np.asarray(imderiv.roi, dtype = np.int)
            self.sky[i] = imderiv.sky
            self.steps[i] = imderiv.steps
        self.cdi = cp.asarray(self.cdi)
        self.steps = cp.asarray(self.steps)

        if self.maxNmogs > 0:
            amp = np.zeros((self.Nimages, self.maxNd, self.maxNmogs))
            mean = np.zeros((self.Nimages, self.maxNd, self.maxNmogs, self.maxD))
            var = np.zeros((self.Nimages, self.maxNd, self.maxNmogs, self.maxD, self.maxD))
            for i, imderiv in enumerate(self.img_derivs):
                if imderiv.nmogs > 0:
                    amp[i, :imderiv.N, :imderiv.nmogs] = imderiv.mog_amp
                    mean[i, :imderiv.N, :imderiv.nmogs, :imderiv.D] = imderiv.mog_mean
                    var[i, :imderiv.N, :imderiv.nmogs, :imderiv.D, :imderiv.D] = imderiv.mog_var
            self.mogs = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
        if self.maxNfft > 0:
            amp = np.zeros((self.Nimages, self.maxNd, self.maxNfft))
            mean = np.zeros((self.Nimages, self.maxNd, self.maxNfft, self.maxD))
            var = np.zeros((self.Nimages, self.maxNd, self.maxNfft, self.maxD, self.maxD))
            for i, imderiv in enumerate(self.img_derivs):
                if imderiv.nfft > 0:
                    amp[i, :imderiv.N, :imderiv.nfft] = imderiv.fft_amp
                    mean[i, :imderiv.N, :imderiv.nfft, :imderiv.D] = imderiv.fft_mean
                    var[i, :imderiv.N, :imderiv.nfft, :imderiv.D, :imderiv.D] = imderiv.fft_var
            self.ffts = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
        #print ("Collected Params")
        #print (f'\t{self.maxNmogs=}, {self.maxNfft=}, {self.mux=}, {self.muy=}')

    def get_imderiv(self, i):
        assert (i < self.Nimages)
        return self.img_derivs[i]


class BatchDerivs(object):
    '''This supercedes the img_dervis list
        N = number of blobs
        ni = number of mogs
        nf = number of ffts
        K, D = dimensions of mean, var
        mogs = BatchMixtureOfGaussians
        ffts = batchMixtureOfGaussians
        names = list of amixes.name
        step = list of amixes.step
    '''

    def __init__(self, amixes, IM, IF, K, D, mogweights, fftweights, px, py, mux, muy):
        N = len(amixes)
        ni = IM.sum()
        nf = IF.sum()
        self.N = N
        self.ni = ni
        self.nf = nf
        self.K = K 
        self.D = D
        self.mogs = None
        self.ffts = None
        self.names = []
        self.steps = []

        self.mux = mux
        self.muy = muy

        if self.ni > 0:
            amp = np.zeros((N, ni))
            mean = np.zeros((N, ni, D))
            var = np.zeros((N, ni, D, D))
            for i, amix in enumerate(amixes):
                (name, mix, step) = amix
                amp[i] = mix.amp[IM] * mogweights
                mean[i] = mix.mean[IM, :] + np.array([px, py])[np.newaxis, :]
                var[i] = mix.var[IM, :, :]
            self.mogs = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
        if self.nf > 0:
            amp = np.zeros((N, nf))
            mean = np.zeros((N, nf, D))
            var = np.zeros((N, nf, D, D))
            for i, amix in enumerate(amixes):
                (name, mix, step) = amix
                amp[i] = mix.amp[IF] * fftweights
                mean[i] = mix.mean[IF, :] + np.array([px, py])[np.newaxis, :]
                var[i] = mix.var[IF, :, :]
            self.ffts = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
        for name,mix,step in amixes: 
            self.names.append(name)
            self.steps.append(step)

    def tostr(self):
        print("****** Batch Derivs *****")
        print(f'\t{self.N=}, {self.ni=}, {self.nf=}, {self.K=}, {self.D=}')
        if self.mogs is None:
            print ("No Mogs")
        else:
            print ("Mogs ", self.mogs)
        if self.ffts is None:
            print ("No FFTs")
        else:
            print("FFTS", self.ffts)
        print ("Names ", self.names)
        print ("Steps ", self.steps)

class ImageBatchDerivs(object):
    '''This supercedes the img_dervis list
        N = number of blobs
        ni = number of mogs
        nf = number of ffts
        K, D = dimensions of mean, var
        mogs = BatchMixtureOfGaussians
        ffts = batchMixtureOfGaussians
        names = list of amixes.name
        step = list of amixes.step
    '''

    def __init__(self, batched_amixes,batched_IM, batched_IF, batched_K, batched_D, batched_mogweights, batched_fftweights, pxy):
        #Ni = number of images
        #Nd = len of img_derivs == 10
        #mean = (Ni, Nd, K, D)
        #amps = (Ni, Nd, K)
        #var = (Ni, Nd, K, D, D)
        self.Ni = len(batched_amixes)
        self.Nd = len(batched_amixes[0])
        #self.N = len(amixes)
        self.batched_nmogs = [IM.sum for IM in batched_IM]
        #self.ni = IM.sum()
        self.batched_nffts = [IF.sum for IF in batched_IF]
        #self.nf = IF.sum() 
        self.batched_K = batched_K 
        #self.K = vshape[0]
        self.batched_D = batched_D
        #self.D = vshape[1]
        self.mogs = None
        self.ffts = None
        self.batched_names = []
        self.batched_steps = []

        max_nmogs = max(batched_nmogs)
        max_nffts = max(batched_nffts)
        max_K = max(batched_K)
        max_D = max(batched_D)
        amp = np.zeros((self.Ni, self.Nd, max_k))
        mean = np.zeros((self.Ni, self.Nd, max_K, max_D))
        var = np.zeros((self.Ni, self.Nd, max_K, max_D, max_D))
        for iimage, amixes in enumerate(batched_amixes):
            if self.batched_nmogs[iimage] > 0:
                for i,name,mix,step in enumerate(amixes):
                    amp[iimage,i,:] = mix.amp[IM] * batched_mogweights[iimage]
                    mean[iiamge,i,:,:] = mix.mean[IM, :] + np.array(pxy[iimage])[np.newaxis, :]
                    var[iimages,i,:,:,:] = mix.var[IM, :, :]
            #self.mogs = ImageBatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
            if self.batched_nf[iimage] > 0:
                for i, name,mix,step in enumerate(amixes):
                    amp[iimage,i,:] = mix.amp[IF] * batched_fftweights[iimage]
                    mean[iimage,i,:,:] = mix.mean[IF, :] + np.array(pxy[iimage])[np.newaxis, :]
                var[image,i] = mix.var[IF, :, :]
        self.ffts = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
        for iimage, amixes in enumerate(batched_amixes):
            for i, name,mix,step in enumerate(amixes):
                self.names = []
                self.steps = []
                self.names.append(name)
                self.steps.append(step)
            self.batched_names[self.names]
            self.batched_steps[self.steps]


class BatchMixtureOfGaussians(object):

    # symmetrize is an unnecessary step in principle, but in practice?
    def __init__(self, amp, mean, var, quick=False):
        '''
        amp: shape (N,K,)
        mean: shape (N,K,D)
        var: shape (N,K,D,D)

        Ni = number of images
        Nd = len of img_derivs == 10
        mean = (Ni, Nd, K, D)
        amps = (Ni, Nd, K)
        var = (Ni, Nd, K, D, D)
        '''
        self.ndims = len(var.shape)
        if self.ndims == 4:
            (self.Nd, self.K, self.D) = mean.shape
        else:
            (self.Ni, self.Nd, self.K, self.D) = mean.shape
        if quick:
            self.amp = amp
            self.mean = mean
            self.var = var
        else:
            self.amp = np.atleast_1d(amp).astype(float)
            self.mean = np.atleast_2d(np.array(mean)).astype(float)
            self.set_var(var)
            self.symmetrize()

    def __str__(self):
        result = "BatchMixtureOfGaussians instance"
        if self.ndims == 4:
            result += " with %d derivs %d components in %d dimensions:\n" % (self.Nd, self.K, self.D)
        else:
            result += " with %d images %d derivs %d components in %d dimensions:\n" % (self.Ni, self.Nd, self.K, self.D)
        result += " amp  = %s\n" % self.amp.__str__()
        result += " mean = %s\n" % self.mean.__str__()
        result += " var  = %s\n" % self.var.__str__()
        return result

    def set_var(self, var):
        self.var = cp.asarray(var)

    def symmetrize(self):
        if self.ndims == 4:
            self.symmetrize4()
        else:
            self.symmetrize5()

    def symmetrize5(self):
        for i in range(self.D):
            for j in range(i):
                tmpij = 0.5 * (self.var[:, :, :, i, j] + self.var[:, :, :, j, i])
                self.var[:, :, :, i, j] = tmpij
                self.var[:, :, :, j, i] = tmpij

    def symmetrize4(self):
        for i in range(self.D):
            for j in range(i):
                tmpij = 0.5 * (self.var[:, :, i, j] + self.var[:, :, j, i])
                self.var[:, :, i, j] = tmpij
                self.var[:, :, j, i] = tmpij

###  --------------- ####
###  Batch GPU version below ###

    def getFourierTransform(self, v, w, zero_mean=False):
        if self.ndims == 4:
            return self.getFourierTransformBatchGPU(v,w, zero_mean)
        else:
            return self.getFourierTransformImagesBatchGPU(v,w, zero_mean)


    def getFourierTransformBatchGPU(self,v,w, zero_mean=False):
        #mean = (N, K, D)
        #amps = (N, K)
        #var = (N, K, D, D)
        #v = (nv) 1d vector of fftfreqs
        #w = (nw) 1d vector of fftfreqs
        mu = self.mean
        a = self.var[:,:,0,0]
        b = self.var[:,:,0,1]
        d = self.var[:,:,1,1]
        #n, K
        F = cp.exp(-2. * cp.pi**2 *
               (a[:,:,cp.newaxis,cp.newaxis]*v[cp.newaxis,cp.newaxis,cp.newaxis,:]**2 +
                d[:,:,cp.newaxis,cp.newaxis]*w[cp.newaxis,cp.newaxis,:,cp.newaxis]**2 +
                2*b[:,:,cp.newaxis,cp.newaxis]*v[cp.newaxis,cp.newaxis,cp.newaxis,:]*w[cp.newaxis,cp.newaxis,:,cp.newaxis]))
        z = cp.logical_or(mu[:,:,0] != 0, mu[:,:,1] != 0)
        if (z.any()):
            F[z] = F[z] * cp.exp(-2. * cp.pi * 1j * (mu[:,:,0,cp.newaxis,cp.newaxis]*v[cp.newaxis,cp.newaxis,cp.newaxis,:] +
                                    mu[:,:,1,cp.newaxis,cp.newaxis]*w[cp.newaxis,cp.newaxis,:,cp.newaxis])[z])

        Fsum = (self.amp[:,:,None,None]*F).sum(axis=1)
        return Fsum

    def getFourierTransformImagesBatchGPU(self,v,w, zero_mean=False):
        #Ni = number of images
        #Nd = len of img_derivs == 10
        #mean = (Ni, Nd, K, D)
        #amps = (Ni, Nd, K)
        #var = (Ni, Nd, K, D, D)
        #v = (nv) 1d vector of fftfreqs
        #w = (nw) 1d vector of fftfreqs
        mu = self.mean
        a = self.var[:,:,:,0,0]
        b = self.var[:,:,:,0,1]
        d = self.var[:,:,:,1,1]

        #n, K
        #5D arrays are fun!
        F = cp.exp(-2. * cp.pi**2 *
                (a[:,:,:,cp.newaxis,cp.newaxis]*v[cp.newaxis,cp.newaxis,cp.newaxis,cp.newaxis,:]**2 +
                 d[:,:,:,cp.newaxis,cp.newaxis]*w[cp.newaxis,cp.newaxis,cp.newaxis,:,cp.newaxis]**2 +
                 2*b[:,:,:,cp.newaxis,cp.newaxis]*v[cp.newaxis,cp.newaxis,cp.newaxis,cp.newaxis,:]*w[cp.newaxis,cp.newaxis,cp.newaxis,:,cp.newaxis]))

        z = cp.logical_or(mu[:,:,:,0] != 0, mu[:,:,:,1] != 0)
        if (z.any()):
            F[z] = F[z] * cp.exp(-2. * cp.pi * 1j * (mu[:,:,:,0,cp.newaxis,cp.newaxis]*v[cp.newaxis,cp.newaxis,cp.newaxis,cp.newaxis,:] +
                                                     mu[:,:,:,1,cp.newaxis,cp.newaxis]*w[cp.newaxis,cp.newaxis,cp.newaxis,:,cp.newaxis])[z])

        Fsum = (self.amp[:,:,:,None,None]*F).sum(axis=2)
        return Fsum
