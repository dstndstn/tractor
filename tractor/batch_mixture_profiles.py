# Copyright 2011 David W. Hogg and Dustin Lang.  All rights reserved.
from __future__ import print_function
if __name__ == '__main__':
    import matplotlib
    matplotlib.use('Agg')
    import pylab as plt
    import matplotlib.cm as cm
import numpy as np
import cupy as cp
import time
import math, gc

# magic arrays, generated by running optimize_mixture_profiles.py:
# (note optimize_mixture_profiles.py now lives in Hogg's TheTractor github repo)
# for "exp" we use the 6-component "lux" models
exp_amp = np.array([2.34853813e-03,   3.07995260e-02,   2.23364214e-01,
                    1.17949102e+00,   4.33873750e+00,   5.99820770e+00])
exp_var = np.array([1.20078965e-03,   8.84526493e-03,   3.91463084e-02,
                    1.39976817e-01,   4.60962500e-01,   1.50159566e+00])
exp_amp /= np.sum(exp_amp)

# for "dev" we use the 8-component "luv" models
dev_amp = np.array([4.26347652e-02,   2.40127183e-01,   6.85907632e-01,   1.51937350e+00,
                    2.83627243e+00,   4.46467501e+00,   5.72440830e+00,   5.60989349e+00])
dev_var = np.array([2.23759216e-04,   1.00220099e-03,   4.18731126e-03,   1.69432589e-02,
                    6.84850479e-02,   2.87207080e-01,   1.33320254e+00,   8.40215071e+00])
#dev_amp /= np.sum(dev_amp)

########## Delta function core to correct for softening
dev_core = 0.010233
dev_amp *= (1. - dev_core) / np.sum(dev_amp)
dev_amp = np.append(dev_amp, dev_core)
dev_var = np.append(dev_var, 0.)
####################

class BatchGalaxyProfiles(object):
    '''This supercedes the img_dervis list
        N = number of blobs
        nmogs = number of mogs
        nfft = number of ffts
        K, D = dimensions of mean, var
        mogs = BatchMixtureOfGaussians
        ffts = batchMixtureOfGaussians
        names = list of amixes.name
        step = list of amixes.step
    ''' 

    def __init__(self, amixes, IM, IF, K, D, mogweights, fftweights, px, py, mux, muy, mmpix, mmie, mh, mw, counts, roi, sky, dx, dy):
        self.Nimages = len(counts)
        N = len(amixes)
        nmogs = IM.sum(axis=2).max(axis=1)
        nfft = IF.sum(axis=2).max(axis=1)
        #print ("nmogs", nmogs.shape)
        #print ("nfft", nfft.shape)
        self.N = N
        self.maxNd = N
        self.nmogs = nmogs
        self.nfft = nfft
        self.K = K
        self.D = D
        self.mogs = None
        self.ffts = None
        self.names = []
        self.steps = []

        self.mux = mux
        self.muy = muy
        self.mmpix = mmpix
        self.mmie = mmie
        self.mh = mh
        self.mw = mw
        self.counts = counts
        self.roi = roi
        self.sky = sky

        self.dx = dx
        self.dy = dy

        #self.maxNmogs = IM.shape[1] 
        #self.maxNfft = IF.shape[1] 

        self.maxNfft = int(nfft.max())
        self.maxNmogs = int(nmogs.max())
        #fftweights = fftweights.get()
        #mogweights = mogweights.get()

        #############  Need to collect MOGS/FFTs in batch ######################
        if self.maxNmogs > 0:
            amp = cp.zeros((self.Nimages, self.N, self.maxNmogs), dtype=cp.float32)
            mean = cp.zeros((self.Nimages, self.N, self.maxNmogs, self.D), dtype=cp.float32)
            var = cp.zeros((self.Nimages, self.N, self.maxNmogs, self.D, self.D), dtype=cp.float32)
            #IM2 = IM[nmogs > 0]
            #flipped_mask = IM2.sum(1, keepdims=1) > cp.arange(self.maxNmogs-1,-1,-1)
            flipped_mask = IM.sum(2, keepdims=1) > cp.arange(self.maxNmogs-1,-1,-1)
            flipped_mask = flipped_mask[:,:,::-1]
            for i, amix in enumerate(amixes):
                (name, mix, step) = amix
                amp[:,i][flipped_mask[:,i]] = (cp.tile(mix.amp, (self.Nimages,1)) * mogweights[:,i])[IM[:,i]]
                mean[:,i][flipped_mask[:,i]] = (cp.tile(mix.mean, (self.Nimages, 1, 1)) + cp.array([px,py]).T[:,cp.newaxis,:])[IM[:,i]]
                var[:,i][flipped_mask[:,i]] = mix.var[IM[:,i]]
            amp = cp.asarray(amp, dtype=cp.float32)
            mean = cp.asarray(mean, dtype=cp.float32)
            var = cp.asarray(var, dtype=cp.float32)
            self.mogs = BatchMixtureOfGaussians(amp, mean, var, quick=True)
            self.mog_amp = amp
            self.mog_mean = mean
            self.mog_var = var
            """
                FAMP (13, 4, 9) (13, 4, 9, 2) (13, 4, 9, 2, 2)
                (9,) (9, 2) (13, 9, 2, 2)
                (13,)

            """
        if self.maxNfft > 0:
            amp = cp.zeros((self.Nimages, self.N, self.maxNfft), dtype=cp.float32)
            mean = cp.zeros((self.Nimages, self.N, self.maxNfft, self.D), dtype=cp.float32)
            var = cp.zeros((self.Nimages, self.N, self.maxNfft, self.D, self.D), dtype=cp.float32)
            #IF2 = IF[nfft > 0]
            #flipped_mask = IF2.sum(2, keepdims=1) > cp.arange(self.maxNfft-1,-1,-1)
            flipped_mask = IF.sum(2, keepdims=1) > cp.arange(self.maxNfft-1,-1,-1)
            flipped_mask = flipped_mask[:,:,::-1]
            #flipped_mask = IF.sum(1, keepdims=1) > cp.arange(self.maxNfft-1,-1,-1)
            #flipped_mask = flipped_mask[:,::-1]
            for i, amix in enumerate(amixes):
                (name, mix, step) = amix
                #print ("FAMP", amp.shape, "FMEAN", mean.shape, "FVAR", var.shape)

                var[:,i][flipped_mask[:,i]] = mix.var[IF[:,i]]
                amp[:,i][flipped_mask[:,i]] = (cp.tile(mix.amp, (self.Nimages,1)) * fftweights[:,i])[IF[:,i]]
                mean[:,i][flipped_mask[:,i]] = cp.tile(mix.mean, (self.Nimages,1,1))[IF[:,i]]

            amp = cp.asarray(amp)
            mean = cp.asarray(mean)
            var = cp.asarray(var)
            self.ffts = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
            self.fft_amp = amp
            self.fft_mean = mean
            self.fft_var = var
        for name,mix,step in amixes:
            self.names.append(name)
            self.steps.append(step)
        self.steps = cp.tile(self.steps, (self.Nimages,1))

    def tostr(self):
        print("****** BatchGalaxyProfiles *****")
        print(f'\t{self.N=}, {self.nmogs=}, {self.nfft=}, {self.K=}, {self.D=}')
        if self.mogs is None:
            print ("No Mogs")
        else:
            print ("Mogs ", self.mogs)
        if self.ffts is None:
            print ("No FFTs")
        else:
            print("FFTS", self.ffts)
        print ("Names ", self.names)
        print ("Steps ", self.steps)
        print (f'\t{self.mux=}, {self.muy=}, {self.mh=}, {self.mw=}')
        print (f'\t{self.counts=}, {self.roi=}')

class ImageDerivs(object):
    '''This supercedes the img_dervis list
        N = number of blobs
        nmogs = number of mogs
        nfft = number of ffts
        K, D = dimensions of mean, var
        mogs = BatchMixtureOfGaussians
        ffts = batchMixtureOfGaussians
        names = list of amixes.name
        step = list of amixes.step
    '''

    def __init__(self, amixes, IM, IF, K, D, mogweights, fftweights, px, py, mux, muy, mmpix, mmie, mh, mw, counts, cdi, roi, sky, dx, dy, fit_pos):
        N = len(amixes)
        #print ("IM", IM.shape, IM, IM.sum(axis=1))
        #print ("IF", IF.shape, IF, IF.sum(axis=1))
        nmogs = IM.sum(axis=1).max()
        nfft = IF.sum(axis=1).max()
        self.N = N
        self.nmogs = nmogs
        self.nfft = nfft
        self.K = K
        self.D = D
        self.mogs = None
        self.ffts = None
        self.names = []
        self.steps = []

        self.mux = mux
        self.muy = muy
        self.mmpix = cp.asarray(mmpix)
        self.mmie = cp.asarray(mmie)
        self.mh = mh
        self.mw = mw
        self.counts = counts
        self.cdi = cdi
        self.roi = roi
        self.sky = sky

        self.dx = dx
        self.dy = dy
        self.fit_pos = fit_pos

        #print ("NMOGS", self.nmogs, "NFFT", self.nfft)
        #print ("IM", IM.shape, IM)
        if self.nmogs > 0:
            amp = np.zeros((N, nmogs))
            mean = np.zeros((N, nmogs, D))
            var = np.zeros((N, nmogs, D, D))
            for i, amix in enumerate(amixes):
                (name, mix, step) = amix
                nm = IM[i].sum()
                #print ("NM", nm)
                #print (IM[i].shape)
                #print (amp.shape, amp[i].shape, amp[i][:nm].shape)
                amp[i][:nm] = mix.amp[IM[i]] * mogweights[i][IM[i]]
                mean[i][:nm] = mix.mean[IM[i], :] + np.array([px, py])[np.newaxis, :]
                var[i][:nm] = mix.var[IM[i], :, :]
            #self.mogs = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
            self.mog_amp = amp
            self.mog_mean = mean
            self.mog_var = var
        if self.nfft > 0:
            amp = np.zeros((N, nfft))
            mean = np.zeros((N, nfft, D))
            var = np.zeros((N, nfft, D, D))
            for i, amix in enumerate(amixes):
                (name, mix, step) = amix
                nf = IF[i].sum()
                amp[i][:nf] = mix.amp[IF[i]] * fftweights[i][IF[i]]
                mean[i][:nf] = mix.mean[IF[i], :]
                var[i][:nf] = mix.var[IF[i], :, :]
                #print ("IFAMP", amp.shape, mean.shape, var.shape)
                #print (mix.amp.shape, mix.mean.shape, mix.var.shape)
                #print (fftweights)
                #"""IFAMP (4, 9) (4, 9, 2) (4, 9, 2, 2)
                #(9,) (9, 2) (9, 2, 2)
                #1.0
                #"""
            #self.ffts = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
            self.fft_amp = amp
            self.fft_mean = mean
            self.fft_var = var
        for name,mix,step in amixes:
            self.names.append(name)
            self.steps.append(step)
        self.steps = np.array(self.steps, dtype=np.float32)

    def tostr(self):
        print("****** ImageDerivs *****")
        print(f'\t{self.N=}, {self.nmogs=}, {self.nfft=}, {self.K=}, {self.D=}')
        if self.mogs is None:
            print ("No Mogs")
        else:
            print ("Mogs ", self.mogs)
        if self.ffts is None:
            print ("No FFTs")
        else:
            print("FFTS", self.ffts)
        print ("Names ", self.names)
        print ("Steps ", self.steps)
        print (f'\t{self.mux=}, {self.muy=}, {self.mh=}, {self.mw=}')
        print (f'\t{self.counts=}, {self.cdi=}, {self.roi=}')


class BatchImageParams(object):
    '''Image Params for a set of images
        img_derivs = list of ImageDerivs
        P = 3d array (Nimages, nw, nv)
        v, w = 1d vectors
    '''

    def __init__(self, P, v, w, psf_mogs):
        self._initialized = False
        self.P = P
        self.v = v
        self.w = w
        self.psf_mogs = psf_mogs

        self.mogs = None
        self.ffts = None

        self.Nimages = 0 
        self.nv = len(v)
        self.nw = len(w)

        self.maxK = 0
        self.maxD = 0
        self.maxNd = 0
        self.maxNmogs = 0
        self.maxNfft = 0

        self.img_derivs = []
        self.mux = None
        self.muy = None

        self.mh = 0
        self.mw = 0

        self.dx = None
        self.dy = None
        self.fit_pos = None

    def add_image_deriv(self, imderiv):
        self.img_derivs.append(imderiv)
        self.Nimages += 1

        self.maxK = max(self.maxK, imderiv.K)
        self.maxD = max(self.maxD, imderiv.D)
        self.maxNd = max(self.maxNd, imderiv.N)
        self.maxNmogs = max(self.maxNmogs, imderiv.nmogs)
        self.maxNfft = max(self.maxNfft, imderiv.nfft)

        self.mh = max(self.mh, imderiv.mh)
        self.mw = max(self.mw, imderiv.mw)

    def addBatchGalaxyDerivs(self, cdi, fit_pos):
        self.cdi = cdi
        self.fit_pos = fit_pos

    def addBatchGalaxyProfiles(self, bimderiv):
        #print ("ADD_BATCH")
        assert(self._initialized is False)
        self._initialized = True
        self.Nimages += bimderiv.Nimages
        self.maxNd = bimderiv.N
        self.maxK = bimderiv.K
        self.maxD = bimderiv.D

        self.maxNmogs = bimderiv.nmogs.max()
        self.maxNfft = bimderiv.nfft.max()
        self.mh = bimderiv.mh
        self.mw = bimderiv.mw

        self.mux = cp.array([bimderiv.mux]*self.maxNd, dtype=cp.float32).T.ravel()
        self.muy = cp.array([bimderiv.muy]*self.maxNd, dtype=cp.float32).T.ravel()
        self.counts = bimderiv.counts
        self.roi = bimderiv.roi
        self.steps = bimderiv.steps
        self.sky = bimderiv.sky
        self.dx = bimderiv.dx
        self.dy = bimderiv.dy

        self.pix = bimderiv.mmpix
        self.ie = bimderiv.mmie
        #print (self.counts.shape, self.cdi.shape, self.roi.shape, self.pix.shape, self.ie.shape)

        self.mogs = bimderiv.mogs
        self.ffts = bimderiv.ffts
        #####
        #print ("Collected Params")
        #print (f'\t{self.maxNmogs=}, {self.maxNfft=}, {self.mux=}, {self.muy=}')


    def collect_params(self):
        assert(self._initialized is False)
        self._initialized = True
        self.mux = cp.asarray([[imderiv.mux]*self.maxNd for imderiv in self.img_derivs]).ravel()
        self.muy = cp.asarray([[imderiv.muy]*self.maxNd for imderiv in self.img_derivs]).ravel()
        self.fit_pos = cp.asarray([imderiv.fit_pos for imderiv in self.img_derivs])

        self.pix = cp.zeros((self.Nimages, self.mh, self.mw), dtype = cp.float32 )
        self.ie = cp.zeros_like(self.pix)
        self.counts = cp.zeros(self.Nimages, dtype=cp.float32)
        self.cdi = np.zeros((self.Nimages, 2,2), dtype=np.float32)
        self.roi = np.zeros((self.Nimages, 4), dtype=np.int)
        self.sky = cp.zeros(self.Nimages, dtype=cp.float32)
        self.steps = np.zeros((self.Nimages, self.maxNd), dtype=np.float32)

        for i, imderiv in enumerate(self.img_derivs):
            self.pix[i, :,:] = cp.pad(imderiv.mmpix, ((0, self.mh - imderiv.mmpix.shape[0]), (0, self.mw - imderiv.mmpix.shape[1])), mode='constant',constant_values=(cp.float32(0.0),))
            self.ie[i, :,:] = cp.pad(imderiv.mmie, ((0, self.mh - imderiv.mmie.shape[0]), (0, self.mw - imderiv.mmie.shape[1])), mode='constant',constant_values=(cp.float32(0.0),))
            self.counts[i] = imderiv.counts
            self.cdi[i] = imderiv.cdi
            self.roi[i] = np.asarray(imderiv.roi, dtype = np.int)
            self.sky[i] = imderiv.sky
            self.steps[i] = imderiv.steps
        self.cdi = cp.asarray(self.cdi)
        self.steps = cp.asarray(self.steps)

        if self.maxNmogs > 0:
            amp = np.zeros((self.Nimages, self.maxNd, self.maxNmogs))
            mean = np.zeros((self.Nimages, self.maxNd, self.maxNmogs, self.maxD))
            var = np.zeros((self.Nimages, self.maxNd, self.maxNmogs, self.maxD, self.maxD))
            for i, imderiv in enumerate(self.img_derivs):
                if imderiv.nmogs > 0:
                    amp[i, :imderiv.N, :imderiv.nmogs] = imderiv.mog_amp
                    mean[i, :imderiv.N, :imderiv.nmogs, :imderiv.D] = imderiv.mog_mean
                    var[i, :imderiv.N, :imderiv.nmogs, :imderiv.D, :imderiv.D] = imderiv.mog_var
            self.mogs = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
        if self.maxNfft > 0:
            amp = np.zeros((self.Nimages, self.maxNd, self.maxNfft))
            mean = np.zeros((self.Nimages, self.maxNd, self.maxNfft, self.maxD))
            var = np.zeros((self.Nimages, self.maxNd, self.maxNfft, self.maxD, self.maxD))
            for i, imderiv in enumerate(self.img_derivs):
                if imderiv.nfft > 0:
                    amp[i, :imderiv.N, :imderiv.nfft] = imderiv.fft_amp
                    mean[i, :imderiv.N, :imderiv.nfft, :imderiv.D] = imderiv.fft_mean
                    var[i, :imderiv.N, :imderiv.nfft, :imderiv.D, :imderiv.D] = imderiv.fft_var
            self.ffts = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
        #print ("Collected Params")
        #print (f'\t{self.maxNmogs=}, {self.maxNfft=}, {self.mux=}, {self.muy=}')

    def get_imderiv(self, i):
        assert (i < self.Nimages)
        return self.img_derivs[i]


class BatchDerivs(object):
    '''This supercedes the img_dervis list
        N = number of blobs
        ni = number of mogs
        nf = number of ffts
        K, D = dimensions of mean, var
        mogs = BatchMixtureOfGaussians
        ffts = batchMixtureOfGaussians
        names = list of amixes.name
        step = list of amixes.step
    '''

    def __init__(self, amixes, IM, IF, K, D, mogweights, fftweights, px, py, mux, muy, fit_pos):
        N = len(amixes)
        ni = IM.sum()
        nf = IF.sum()
        self.N = N
        self.ni = ni
        self.nf = nf
        self.K = K 
        self.D = D
        self.mogs = None
        self.ffts = None
        self.names = []
        self.steps = []

        self.mux = mux
        self.muy = muy
        self.fit_pos = fit_pos

        if self.ni > 0:
            amp = np.zeros((N, ni))
            mean = np.zeros((N, ni, D))
            var = np.zeros((N, ni, D, D))
            for i, amix in enumerate(amixes):
                (name, mix, step) = amix
                amp[i] = mix.amp[IM] * mogweights
                mean[i] = mix.mean[IM, :] + np.array([px, py])[np.newaxis, :]
                var[i] = mix.var[IM, :, :]
            self.mogs = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
        if self.nf > 0:
            amp = np.zeros((N, nf))
            mean = np.zeros((N, nf, D))
            var = np.zeros((N, nf, D, D))
            for i, amix in enumerate(amixes):
                (name, mix, step) = amix
                amp[i] = mix.amp[IF] * fftweights
                mean[i] = mix.mean[IF, :] + np.array([px, py])[np.newaxis, :]
                var[i] = mix.var[IF, :, :]
            self.ffts = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
        for name,mix,step in amixes: 
            self.names.append(name)
            self.steps.append(step)

    def tostr(self):
        print("****** Batch Derivs *****")
        print(f'\t{self.N=}, {self.ni=}, {self.nf=}, {self.K=}, {self.D=}')
        if self.mogs is None:
            print ("No Mogs")
        else:
            print ("Mogs ", self.mogs)
        if self.ffts is None:
            print ("No FFTs")
        else:
            print("FFTS", self.ffts)
        print ("Names ", self.names)
        print ("Steps ", self.steps)

class ImageBatchDerivs(object):
    '''This supercedes the img_dervis list
        N = number of blobs
        ni = number of mogs
        nf = number of ffts
        K, D = dimensions of mean, var
        mogs = BatchMixtureOfGaussians
        ffts = batchMixtureOfGaussians
        names = list of amixes.name
        step = list of amixes.step
    '''

    def __init__(self, batched_amixes,batched_IM, batched_IF, batched_K, batched_D, batched_mogweights, batched_fftweights, pxy):
        #Ni = number of images
        #Nd = len of img_derivs == 10
        #mean = (Ni, Nd, K, D)
        #amps = (Ni, Nd, K)
        #var = (Ni, Nd, K, D, D)
        self.Ni = len(batched_amixes)
        self.Nd = len(batched_amixes[0])
        #self.N = len(amixes)
        self.batched_nmogs = [IM.sum for IM in batched_IM]
        #self.ni = IM.sum()
        self.batched_nffts = [IF.sum for IF in batched_IF]
        #self.nf = IF.sum() 
        self.batched_K = batched_K 
        #self.K = vshape[0]
        self.batched_D = batched_D
        #self.D = vshape[1]
        self.mogs = None
        self.ffts = None
        self.batched_names = []
        self.batched_steps = []

        max_nmogs = max(batched_nmogs)
        max_nffts = max(batched_nffts)
        max_K = max(batched_K)
        max_D = max(batched_D)
        amp = np.zeros((self.Ni, self.Nd, max_k))
        mean = np.zeros((self.Ni, self.Nd, max_K, max_D))
        var = np.zeros((self.Ni, self.Nd, max_K, max_D, max_D))
        for iimage, amixes in enumerate(batched_amixes):
            if self.batched_nmogs[iimage] > 0:
                for i,name,mix,step in enumerate(amixes):
                    amp[iimage,i,:] = mix.amp[IM] * batched_mogweights[iimage]
                    mean[iiamge,i,:,:] = mix.mean[IM, :] + np.array(pxy[iimage])[np.newaxis, :]
                    var[iimages,i,:,:,:] = mix.var[IM, :, :]
            #self.mogs = ImageBatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
            if self.batched_nf[iimage] > 0:
                for i, name,mix,step in enumerate(amixes):
                    amp[iimage,i,:] = mix.amp[IF] * batched_fftweights[iimage]
                    mean[iimage,i,:,:] = mix.mean[IF, :] + np.array(pxy[iimage])[np.newaxis, :]
                var[image,i] = mix.var[IF, :, :]
        self.ffts = BatchMixtureOfGaussians(cp.asarray(amp), cp.asarray(mean), cp.asarray(var), quick=True)
        for iimage, amixes in enumerate(batched_amixes):
            for i, name,mix,step in enumerate(amixes):
                self.names = []
                self.steps = []
                self.names.append(name)
                self.steps.append(step)
            self.batched_names[self.names]
            self.batched_steps[self.steps]


class BatchMixtureOfGaussians(object):

    # symmetrize is an unnecessary step in principle, but in practice?
    def __init__(self, amp, mean, var, quick=False, unbalanced=False):
        '''
        amp: shape (N,K,)
        mean: shape (N,K,D)
        var: shape (N,K,D,D)

        Ni = number of images
        Nd = len of img_derivs == 10
        mean = (Ni, Nd, K, D)
        amps = (Ni, Nd, K)
        var = (Ni, Nd, K, D, D)
        '''
        self.ndims = len(var.shape)
        self.unbalanced = unbalanced
        if self.ndims == 3:
            (self.K, self.D) = mean.shape
        elif self.ndims == 4:
            if unbalanced:
                (self.K, self.D) = mean.shape
                self.Nd = var.shape[1]
            else:
                (self.Nd, self.K, self.D) = mean.shape
        else:
            (self.Ni, self.Nd, self.K, self.D) = mean.shape
        if quick:
            self.amp = amp
            self.mean = mean
            self.var = var
        else:
            self.amp = np.atleast_1d(amp).astype(float)
            self.mean = np.atleast_2d(np.array(mean)).astype(float)
            self.set_var(var)
            self.symmetrize()

    def __str__(self):
        result = "BatchMixtureOfGaussians instance"
        if self.ndims == 4:
            result += " with %d derivs %d components in %d dimensions:\n" % (self.Nd, self.K, self.D)
        else:
            result += " with %d images %d derivs %d components in %d dimensions:\n" % (self.Ni, self.Nd, self.K, self.D)
        result += " amp  = %s\n" % self.amp.__str__()
        result += " mean = %s\n" % self.mean.__str__()
        result += " var  = %s\n" % self.var.__str__()
        return result

    def set_var(self, var):
        self.var = cp.asarray(var)

    def symmetrize(self):
        if self.ndims == 3:
            if self.unbalanced:
                self.symmetrize4()
            else:
                self.symmetrize3()
        elif self.ndims == 4:
            self.symmetrize4()
        else:
            self.symmetrize5()

    def symmetrize5(self):
        for i in range(self.D):
            for j in range(i):
                tmpij = 0.5 * (self.var[:, :, :, i, j] + self.var[:, :, :, j, i])
                self.var[:, :, :, i, j] = tmpij
                self.var[:, :, :, j, i] = tmpij

    def symmetrize4(self):
        for i in range(self.D):
            for j in range(i):
                tmpij = 0.5 * (self.var[:, :, i, j] + self.var[:, :, j, i])
                self.var[:, :, i, j] = tmpij
                self.var[:, :, j, i] = tmpij

###  --------------- ####
###  Batch GPU version below ###

    def getFourierTransform(self, v, w, zero_mean=False):
        if self.ndims == 4:
            return self.getFourierTransformBatchGPU(v,w, zero_mean)
        else:
            return self.getFourierTransformImagesBatchGPU(v,w, zero_mean)


    def getFourierTransformBatchGPU(self,v,w, zero_mean=False):
        #mean = (N, K, D)
        #amps = (N, K)
        #var = (N, K, D, D)
        #v = (nv) 1d vector of fftfreqs
        #w = (nw) 1d vector of fftfreqs
        mu = self.mean
        a = self.var[:,:,0,0]
        b = self.var[:,:,0,1]
        d = self.var[:,:,1,1]

        #n, K
        F = cp.exp(-2. * cp.pi**2 *
               (a[:,:,cp.newaxis,cp.newaxis]*v[cp.newaxis,cp.newaxis,cp.newaxis,:]**2 +
                d[:,:,cp.newaxis,cp.newaxis]*w[cp.newaxis,cp.newaxis,:,cp.newaxis]**2 +
                2*b[:,:,cp.newaxis,cp.newaxis]*v[cp.newaxis,cp.newaxis,cp.newaxis,:]*w[cp.newaxis,cp.newaxis,:,cp.newaxis]))
        z = cp.logical_or(mu[:,:,0] != 0, mu[:,:,1] != 0)
        if (z.any()):
            F[z] = F[z] * cp.exp(-2. * cp.pi * 1j * (mu[:,:,0,cp.newaxis,cp.newaxis]*v[cp.newaxis,cp.newaxis,cp.newaxis,:] +
                                    mu[:,:,1,cp.newaxis,cp.newaxis]*w[cp.newaxis,cp.newaxis,:,cp.newaxis])[z])

        Fsum = (self.amp[:,:,None,None]*F).sum(axis=1)
        del F, z, a, b, d
        return Fsum

    def getFourierTransformImagesBatchGPU(self,v,w, zero_mean=False):
        #Ni = number of images
        #Nd = len of img_derivs == 10
        #mean = (Ni, Nd, K, D)
        #amps = (Ni, Nd, K)
        #var = (Ni, Nd, K, D, D)
        #v = (nv) 1d vector of fftfreqs
        #w = (nw) 1d vector of fftfreqs
        mu = self.mean
        a = self.var[:,:,:,0,0]
        b = self.var[:,:,:,0,1]
        d = self.var[:,:,:,1,1]
        #print ("GFT VAR", self.var, self.var.shape)
        #print ("MEAN", self.mean)
        #print ("AMP", self.amp)
        #np.savetxt('gvar.txt', self.var.ravel())

        if v.size > 256:
            #Chunk large arrays
            sz = v.size*w.size*a.shape[0]*a.shape[1]*a.shape[2]
            return self.calculate_Fsum_memory_efficient(a, d, b, mu, v, w, 1)

        #n, K
        #5D arrays are fun!
        F = cp.exp(-2. * cp.pi**2 *
                (a[:,:,:,cp.newaxis,cp.newaxis]*v[cp.newaxis,cp.newaxis,cp.newaxis,cp.newaxis,:]**2 +
                 d[:,:,:,cp.newaxis,cp.newaxis]*w[cp.newaxis,cp.newaxis,cp.newaxis,:,cp.newaxis]**2 +
                 2*b[:,:,:,cp.newaxis,cp.newaxis]*v[cp.newaxis,cp.newaxis,cp.newaxis,cp.newaxis,:]*w[cp.newaxis,cp.newaxis,cp.newaxis,:,cp.newaxis]))

        z = cp.logical_or(mu[:,:,:,0] != 0, mu[:,:,:,1] != 0)
        if (z.any()):
            F[z] = F[z] * cp.exp(-2. * cp.pi * 1j * (mu[:,:,:,0,cp.newaxis,cp.newaxis]*v[cp.newaxis,cp.newaxis,cp.newaxis,cp.newaxis,:] +
                                                     mu[:,:,:,1,cp.newaxis,cp.newaxis]*w[cp.newaxis,cp.newaxis,cp.newaxis,:,cp.newaxis])[z])

        Fsum = (self.amp[:,:,:,None,None]*F).sum(axis=2)
        del F, z, a, b, d
        return Fsum

    def calculate_Fsum_memory_efficient(self, a, d, b, mu, v, w, chunk_size_k=1):
        Ni, Nd_full, K_full, _ = mu.shape # Now Nd_full is 4, K_full is 9
        nw_len = w.shape[0] # 1024
        nv_len = v.shape[0] # 513

        Fsum_dtype = cp.complex64 # Confirmed all float32 inputs -> complex64 output

        # Fsum will have shape (Ni, Nd_full, nw_len, nv_len)
        Fsum = cp.zeros((Ni, Nd_full, nw_len, nv_len), dtype=Fsum_dtype)

        # Iterate in chunks over the K dimension (the one with size 9)
        num_k_chunks = math.ceil(K_full / chunk_size_k)

        for i in range(num_k_chunks):
            start_idx = i * chunk_size_k
            end_idx = min((i + 1) * chunk_size_k, K_full)
            current_chunk_size_k = end_idx - start_idx

            if current_chunk_size_k == 0:
                continue

            print(f"Processing chunk {i+1}/{num_k_chunks} (K indices: {start_idx}-{end_idx-1})")
            # Slice inputs for the current chunk along the K dimension (axis=2)
            a_chunk = a[:, :, start_idx:end_idx] # (Ni, Nd, current_chunk_size_k)
            d_chunk = d[:, :, start_idx:end_idx] # (Ni, Nd, current_chunk_size_k)
            b_chunk = b[:, :, start_idx:end_idx] # (Ni, Nd, current_chunk_size_k)
            mu_chunk = mu[:, :, start_idx:end_idx, :] # (Ni, Nd, current_chunk_size_k, 2)
            amp_chunk = self.amp[:, :, start_idx:end_idx] # (Ni, Nd, current_chunk_size_k)

            # Calculate the first part of F (real exponential)
            # Dimensions: (Ni, Nd, current_chunk_size_k, nw_len, nv_len)
            term1 = a_chunk[:,:,:,cp.newaxis,cp.newaxis] * v[cp.newaxis,cp.newaxis,cp.newaxis,cp.newaxis,:]**2
            term2 = d_chunk[:,:,:,cp.newaxis,cp.newaxis] * w[cp.newaxis,cp.newaxis,cp.newaxis,:,cp.newaxis]**2
            term3 = 2 * b_chunk[:,:,:,cp.newaxis,cp.newaxis] * v[cp.newaxis,cp.newaxis,cp.newaxis,cp.newaxis,:] * w[cp.newaxis,cp.newaxis,cp.newaxis,:,cp.newaxis]

            F_real_part = cp.exp(-2. * cp.pi**2 * (term1 + term2 + term3))

            # Calculate the second part of F (complex exponential conditional on z)
            # z_chunk will have shape (Ni, Nd, current_chunk_size_k)
            z_chunk = cp.logical_or(mu_chunk[:,:,:,0] != 0, mu_chunk[:,:,:,1] != 0)

            if z_chunk.any():
                # Create a full 5D boolean mask from z_chunk for broadcasting
                # z_full_mask will be (Ni, Nd, current_chunk_size_k, nw_len, nv_len)
                z_full_mask = z_chunk[:,:,:,cp.newaxis,cp.newaxis].repeat(nw_len, axis=3).repeat(nv_len, axis=4)

                mu_term_v = mu_chunk[:,:,:,0,cp.newaxis,cp.newaxis] * v[cp.newaxis,cp.newaxis,cp.newaxis,cp.newaxis,:]
                mu_term_w = mu_chunk[:,:,:,1,cp.newaxis,cp.newaxis] * w[cp.newaxis,cp.newaxis,cp.newaxis,:,cp.newaxis]
                mu_dot_vw_sum = mu_term_v + mu_term_w

                complex_factor = cp.exp(-2. * cp.pi * 1j * mu_dot_vw_sum)
                F_chunk = cp.where(z_full_mask, F_real_part * complex_factor, F_real_part)
            else:
                F_chunk = F_real_part

            # Element-wise multiplication with amp_chunk and then sum along the K dimension (axis=2 of F_chunk)
            # (Ni, Nd, nw_len, nv_len) += (Ni, Nd, current_chunk_size_k, 1, 1) * (Ni, Nd, current_chunk_size_k, nw_len, nv_len)
            # then sum over the current_chunk_size_k axis (axis=2 of F_chunk).
            Fsum += (amp_chunk[:,:,:,cp.newaxis,cp.newaxis] * F_chunk).sum(axis=2)

            # Explicitly free memory for intermediate arrays within the loop
            del a_chunk, d_chunk, b_chunk, mu_chunk, amp_chunk
            del term1, term2, term3, F_real_part
            del z_chunk
            try: # These might not exist if z_chunk.any() was False
                del mu_term_v, mu_term_w, mu_dot_vw_sum
                del z_full_mask, complex_factor
                del F_chunk
            except NameError:
                pass

            # Clear the CuPy memory pool after each chunk
            mempool = cp.get_default_memory_pool()
            mempool.free_all_blocks()
            cp.cuda.Device().synchronize() # Ensure all operations complete and memory is truly free
        return Fsum

    def apply_shear_GPU(self, scale):
        var = cp.asarray(self.var)
        scale = cp.asarray(scale)
        newvar = cp.einsum("...ij,...jk", scale.dot(var).swapaxes(1,2), scale.swapaxes(1,2)[:,None,:,:])
        return BatchMixtureOfGaussians(self.amp, self.mean, newvar, quick=True, unbalanced=True)
